KeyW proc
var maint
lCurly {
KeyW proc
var inner1proc
lCurly {
KeyW return
operator ;
rCurly }
comma ,
KeyW return
operator ;
rCurly }
comma ,
KeyW proc
var inner2proc
lCurly {
KeyW proc
var innerinner
lCurly {
KeyW call
var inner1proc
operator ;
KeyW return
operator ;
rCurly }
comma ,
KeyW call
var innerinner
operator ;
KeyW if
lPar (
string SS
rPar )
KeyW then
lCurly {
KeyW if
lPar (
num 34
rPar )
KeyW then
lCurly {
KeyW if
lPar (
KeyW true
rPar )
KeyW then
lCurly {
KeyW do
lCurly {
KeyW call
var inner1proc
operator ;
rCurly }
KeyW until
lPar (
KeyW false
rPar )
operator ;
rCurly }
operator ;
rCurly }
KeyW else
lCurly {
KeyW if
lPar (
KeyW false
rPar )
KeyW then
lCurly {
rCurly }
operator ;
rCurly }
operator ;
rCurly }
operator ;
KeyW while
lPar (
var xx
rPar )
KeyW do
lCurly {
var ud
operator :=
var hi
lBra [
num 10
rBra ]
operator ;
rCurly }
operator ;
KeyW return
operator ;
rCurly }
comma ,
KeyW main
lCurly {
var we
operator :=
var we
operator ;
var we
operator :=
var we2self
operator ;
KeyW if
lPar (
KeyW input
lPar (
var ef
rPar )
rPar )
KeyW then
lCurly {
KeyW output
operator :=
string PRINT
operator ;
rCurly }
operator ;
KeyW if
lPar (
KeyW not
lPar (
KeyW false
rPar )
rPar )
KeyW then
lCurly {
KeyW do
lCurly {
var re
operator :=
KeyW larger
lPar (
num 23
comma ,
KeyW true
rPar )
operator ;
rCurly }
KeyW until
lPar (
KeyW mult
lPar (
KeyW false
comma ,
KeyW true
rPar )
rPar )
operator ;
rCurly }
KeyW else
lCurly {
KeyW output
operator :=
KeyW or
lPar (
string 1
comma ,
string 0
rPar )
operator ;
rCurly }
operator ;
KeyW halt
operator ;
KeyW num
var hello
operator ;
KeyW bool
var okay
operator ;
rCurly }
